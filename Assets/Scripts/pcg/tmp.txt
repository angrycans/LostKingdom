class PCGBasic extends PCG {
  int layout_type; // Layout type
  int room_type; // Room type
  int room_max; // Max room size
  int room_min; // Min room size
  int room_num; // Number of rooms
  int room_base;
  int room_radix;
  boolean room_blocked = false; // If room is blocked
  int redo = 1000; // Recursion limit
  ArrayList rooms; // Room arraylist
  int corridor_num;
  int corridor_weight;
  int turning_weight;

  PCGBasic()
  {
  }

  public void updateParam(int g_width, int g_height, int r_type, int r_min, int r_max, int c_num, int c_weight, int t_weight)
  {
    super.updateParam(g_width, g_height);
    room_type = r_type; // Room type
    
    room_min = r_min; // Default 9
    room_max = r_max; // Default 16
    room_base = PApplet.parseInt((room_min + 1)*0.5f);
    room_radix = PApplet.parseInt((room_max - room_min)*0.5f + 1);
    
    switch(room_type) {
      case 0: room_num = (pcgrid_width*pcgrid_height)/PApplet.parseInt(random(room_min, room_max)*room_max) + 1;
              break; // Scattered
      case 1: room_num = (pcgrid_width*pcgrid_height)/PApplet.parseInt(random(room_min, room_max)*room_max*2) + 1;
              break; // Sparse
      case 2: room_num = (pcgrid_width*pcgrid_height)/PApplet.parseInt(random(room_min, room_max)*room_min*0.5f) + 1;
              break; // Dense
      default: room_num = (pcgrid_width*pcgrid_height)/PApplet.parseInt(random(room_min, room_max)*room_max) + 1;
              break; // Scattered
    }
    
    corridor_num = c_num;
    corridor_weight = c_weight;
    turning_weight = t_weight;
  }

  public void generatePCGBasic(byte[][] g)
  {
    super.generatePCG(g); // Init grid 
    
    initRooms(); // Initialize rooms
    initCorridors(); // Initialize corridors
  }
  
  public void initRooms()
  {
    rooms = new ArrayList(); // New room arraylist
    for (int n = 0; n < room_num; n++) {
      room_blocked = false; // Unblock
      Room rm = new Room(pcgrid_width, pcgrid_height, room_base, room_radix, corridor_num); // Create new room
      room_blocked = blockRoom(rm); // Check if room is blocked
            
      if (room_blocked) {
        n--; // Remake room
        redo--; // Stops if taking too long
        if (redo == 0) {
          room_num--;
          redo = 1000; // Recursion limit
        }
      }
      else {
        rooms.add(rm);
        // Create room
        for (int j = rm.room_y1; j <= rm.room_y2; j++) {
          for (int i = rm.room_x1; i <= rm.room_x2; i++) {
              pcgrid[i][j] = 1;
          }
        }
        // Create room walls
        for (int i = rm.wall_x1; i <= rm.wall_x2; i++) {
          if (pcgrid[i][rm.wall_y1] != 1) pcgrid[i][rm.wall_y1] = 2;
          if (pcgrid[i][rm.wall_y2] != 1) pcgrid[i][rm.wall_y2] = 2;
        }
        for (int j = rm.wall_y1; j <= rm.wall_y2; j++) {
          if (pcgrid[rm.wall_x1][j] != 1) pcgrid[rm.wall_x1][j] = 2;
          if (pcgrid[rm.wall_x2][j] != 1) pcgrid[rm.wall_x2][j] = 2;
        }
        // Place openings
        for (int k = 0; k < rm.opening_num; k++) {
          if (pcgrid[rm.opening[k][0]][rm.opening[k][1]] != 1) pcgrid[rm.opening[k][0]][rm.opening[k][1]] = 3;
        }
      }
    }
  }
  
  public boolean blockRoom(Room rm)
  {
    // If outside of grid
    if (!bounded(rm.wall_x1, rm.wall_y1) || !bounded(rm.wall_x2, rm.wall_y1) ||
        !bounded(rm.wall_x1, rm.wall_y2) || !bounded(rm.wall_x2, rm.wall_y2)) {
        return true;
    }
    // If blocked by another room
    if (room_type != 3) {
      for (int i = rm.wall_x1 - 1; i < rm.wall_x2 + 1; i++) {
        // Check upper and lower bound
        if (bounded(i, rm.wall_y1 - 1) && !blocked(i, rm.wall_y1 - 1, 0)) return true;
        if (bounded(i, rm.wall_y2 + 1) && !blocked(i, rm.wall_y2 + 1, 0)) return true;
      }
      for (int j = rm.wall_y1 - 1; j < rm.wall_y2 + 1; j++) {
        // Check left and right bound
        if (bounded(rm.wall_x1 - 1, j) && !blocked(rm.wall_x1 - 1, j, 0)) return true;
        if (bounded(rm.wall_x2 + 1, j) && !blocked(rm.wall_x2 + 1, j, 0)) return true;
      }
    }
    return false;
  }
  
  public void initCorridors()
  {
    if (room_type != 3) {
      for (int i = 0; i < rooms.size(); i++) {
        // Go through each room and connect its first opening to the first opening of the next room
        Room rm1 = (Room) rooms.get(i);
        Room rm2;
        if (i == rooms.size() - 1) rm2 = (Room) rooms.get(0);
        else rm2 = (Room) rooms.get(i + 1); // If not last room
        
        // Connect rooms
        basicAStar(pcgrid, rm1.opening[0][0], rm1.opening[0][1], rm2.opening[0][0], rm2.opening[0][1], corridor_weight, turning_weight);
        
        // Random tunneling
        for (int j = 1; j < rm1.opening_num; j++) {
          tunnelRandom(rm1.opening[j][0], rm1.opening[j][1], rm1.opening[j][2], 3);
        }
      }
    }
    else { // If complex
      Room rm1 = (Room) rooms.get(0);
      for (int i = 1; i < rooms.size(); i++) {
        // Go through each room and connect its first opening to the first opening of the first room
        Room rm2 = (Room) rooms.get(i);
        // Connect rooms
        basicAStar(pcgrid, rm1.opening[0][0], rm1.opening[0][1], rm2.opening[0][0], rm2.opening[0][1], corridor_weight, turning_weight);
      }        
      // Random tunneling
      for (int i = 0; i < rooms.size(); i++) {
        Room rm3 = (Room) rooms.get(i);
        for (int j = 1; j < rm3.opening_num; j++) {
          tunnelRandom(rm3.opening[j][0], rm3.opening[j][1], rm3.opening[j][2], 3);
        }
      }
    }
  }
  public void tunnelRandom(int x, int y, int dir, int iteration)
  {
    if (iteration == 0) return; // End of recursion iteration
    
    // Choose a random direction and check to see if that cell is occupied, if not, head in that direction
    switch (dir) {
      case 0: if (!blockCorridor(x, y - 1, 0)) tunnel(x, y - 1, dir); // North
              else tunnelRandom(x, y, shuffleDir(dir, 0), iteration - 1); // Try again
              break;
      case 1: if (!blockCorridor(x + 1, y, 1)) tunnel(x + 1, y, dir); // East
              else tunnelRandom(x, y, shuffleDir(dir, 0), iteration - 1); // Try again
              break;
      case 2: if (!blockCorridor(x, y + 1, 0)) tunnel(x, y + 1, dir); // South
              else tunnelRandom(x, y, shuffleDir(dir, 0), iteration - 1); // Try again
              break;
      case 3: if (!blockCorridor(x - 1, y, 1)) tunnel(x - 1, y, dir); // West
              else tunnelRandom(x, y, shuffleDir(dir, 0), iteration - 1); // Try again
              break;
    }
  }
  
  public void tunnel(int x, int y, int dir)
  {
    if (pcgrid[x][y] == 2 || pcgrid[x][y] == 3) pcgrid[x][y] = 3; // If on top of wall or door
    else {
      pcgrid[x][y] = 4; // Set cell to corridor
      tunnelRandom(x, y, shuffleDir(dir, 85), 3); // Randomly choose next cell to go to
    }
  }
  
  public int shuffleDir(int dir, int prob)
  {
    // Randomly choose direction based on probability
    if (PApplet.parseInt(random(100)) > (100 - prob)) {
      return dir; // Stay same direction
    }
    else { // Change direction
      switch (dir) {
        case 0: if (PApplet.parseInt(random(100)) < 50) return 1; // East
                if (PApplet.parseInt(random(100)) >= 50) return 3; // West
                break;
        case 1: if (PApplet.parseInt(random(100)) < 50) return 0; // North
                if (PApplet.parseInt(random(100)) >= 50) return 2; // South
                break;
        case 2: if (PApplet.parseInt(random(100)) < 50) return 1; // East
                if (PApplet.parseInt(random(100)) >= 50) return 3; // West
                break;
        case 3: if (PApplet.parseInt(random(100)) < 50) return 0; // North
                if (PApplet.parseInt(random(100)) >= 50) return 2; // South
                break;     
      }
    }
    return dir;
  }
  
  public boolean blockCorridor(int x, int y, int orientation)
  {
    if (!bounded(x, y)) return true; // If outside of grid
    
    // Check if current cell is available as corridor based on previous corridor cell location
    switch (orientation) {
       // N/S
      case 0: if (blocked(x, y, 1) || // Blocked by room
                  (blocked(x - 1, y, 4) && blocked(x - 1, y + 1, 4)) || // Next to corridor
                  (blocked(x - 1, y, 4) && blocked(x - 1, y - 1, 4)) || // Next to corridor
                  (blocked(x + 1, y, 4) && blocked(x + 1, y + 1, 4)) || // Next to corridor
                  (blocked(x + 1, y, 4) && blocked(x + 1, y - 1, 4)) || // Next to corridor
                  ((blocked(x, y, 2) || blocked(x, y, 3)) && (((blocked(x, y - 1, 2) || blocked(x, y - 1, 3)) && (blocked(x + 1, y, 2) || blocked(x + 1, y, 2))) ||
                                                             ((blocked(x, y - 1, 2) || blocked(x, y - 1, 3)) && (blocked(x - 1, y, 2) || blocked(x - 1, y, 2))) ||
                                                             ((blocked(x, y + 1, 2) || blocked(x, y + 1, 3)) && (blocked(x + 1, y, 2) || blocked(x + 1, y, 2))) ||
                                                             ((blocked(x, y + 1, 2) || blocked(x, y + 1, 3)) && (blocked(x - 1, y, 2) || blocked(x - 1, y, 2))))))
                  return true;
              break;
      // W/E
      case 1: if (blocked(x, y, 1) || // Blocked by room
                  (blocked(x, y - 1, 4) && blocked(x - 1, y + 1, 4)) || // Next to corridor
                  (blocked(x, y - 1, 4) && blocked(x - 1, y - 1, 4)) || // Next to corridor
                  (blocked(x, y + 1, 4) && blocked(x + 1, y + 1, 4)) || // Next to corridor
                  (blocked(x, y + 1, 4) && blocked(x + 1, y - 1, 4)) || // Next to corridor
                  ((blocked(x, y, 2) || blocked(x, y, 3)) && (((blocked(x, y - 1, 2) || blocked(x, y - 1, 3)) && (blocked(x + 1, y, 2) || blocked(x + 1, y, 2))) ||
                                                             ((blocked(x, y - 1, 2) || blocked(x, y - 1, 3)) && (blocked(x - 1, y, 2) || blocked(x - 1, y, 2))) ||
                                                             ((blocked(x, y + 1, 2) || blocked(x, y + 1, 3)) && (blocked(x + 1, y, 2) || blocked(x + 1, y, 2))) ||
                                                             ((blocked(x, y + 1, 2) || blocked(x, y + 1, 3)) && (blocked(x - 1, y, 2) || blocked(x - 1, y, 2))))))
                  return true;
              break;  
    }
    
    return false;    
  }
}
